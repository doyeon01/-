추상의 관점으로 바라보는 객체지향

# Object 

추상화된 코드 [데이터 + 코드]

# 협력과 책임

객체간의 협력과 객체가 담당하는 책임

> 캡슐화 추상화 상속 다형성

추상화의 하위 개념으로 캡슐화가 될 수 있다.
상속도 꼭 필요한 곳에서만 사용하자

# 관심사의 분리 (Seperation of Concern)

높은 응집도와 낮은 결합도 

> 특정한 관심사로 높은 응집도 
> 각 관심사 끼리는 낮은 결합도

---

# 객체 설계하기


객체의 책임을 공개 메서드를 통해서 드러낼 수 있다.
이러한 객체들이 모여서 협력을 함

#### 객체가 제공하는 것
- 절차 지향에서 잘 보이지 않았던 개념을 가시화
- 관심사가 한 군데로 모이기 때문에, 유지보수성 상승
	- ex) 객체 내부에서 객체가 가진 데이터의 유효성 검증 책임을 가질 수 있다.
- 여러 객체를 사용하는 입장에서는, 구체적인 구현에 신경 쓰지 않고 보다 높은 추상화 레벨에서 도메인 로직을 다룰 수 있다. 

#### 새로운 객체를 만들 떄 주의할 점 
- 1개의 관심사로 명확하게 책임이 정의되었는지 확인하기
	- 메서드를 추상화할 때와 비슷하다
	- 객체를 만듦으로써 외부 세계와 어떤 소통을 하려고 하는지 생각하기
- 생성자, 정적 팩토리 메서드에서 유효성 검증이 가능하다.
	- 도메인에 특화된 검증 로직이 들어갈 수 있다.
- setter 사용 자제
	- 데이터는 불변이 최고, 변하는 데이터라도 객체가 핸들링 할 수 있어야한다.
	- 객체 내부에서 외부 세계의 개입 없이 자체적인 변경/가공으로 처리할 수 있는지를 확인
	- 만약 외부에서 가지고 있는 데이터로 데이터 변경 요청을 해야 하는 경우,
	  `set~` 이라는 단순한 이름 보다는
	  `update~` 같이 의도를 드러내는 네이밍을 고려하자
- `getter`도 처음에는 사용 자제, 반드시 필요한 경우에 추가하기

- getter 남발 x 

- 필드의 수는 적을수록 좋다.
- 미리 가공하는 것이 성능 상 이점이 있다면 필드로 가지고  있는 것이 좋을 수 있다. 아니면 긔떄 그떄 계산하기


> 도메인 지식은 만드는 것이 아니라 발견하는 것..!
> 새로운 도메인 지식을 발견했을 때는 과감하게 리팩토링 하자



### SRP : Single Responsibility Principle
단일 책임 원칙

- 하나의 클래스는 단 한 가지의 변경 이유만을 가져야 한다.(변경 이유 == 책임)
- 객체가 가진 공개 메서드 , 필드, 상수 등은 해당 객체의 ==단일 책임에 의해서만 변경 되는가==?
- 관심사 분리
- 높은 응집도, 낮은 결합도



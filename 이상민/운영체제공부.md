## 기본

- OS란
    
    ### OS란?
    
    운영체제는 사용자와 하드웨어 간 인터페이스로서 동작하는 시스템 소프트웨어의 일종으로, 다른 응용프로그램이 유용한 작업을 할 수 있도록 환경을 제공한다.
    
    ### 운영체제의 종류
    
    Window, 맥 OS, 리눅스, 유닉스 등
    
    **window**
    
    - 마이크로 소프트 기업이 자사의 MS-DOS에 다중 작업 기능과 GUI환경을 추가.
    - 세계적으로 많은 점유율, 사용자 편의성을 위주로 만들어져 쉽게 쓸 수있는것에 초점이 맞춰져 있다.
    
    **맥 OS**
    
    - 애플 계열 전용 OS.
    - 유닉스 계열, 터미널이라는 근간으로 개발도 편하게 할 수 있게 되어있다.
    
    **리눅스**
    
    - 모바일 운영체제인 안드로이드, IOS는 모두 다 리눅스 커널기반
    - 유닉스 계열에 있는 굉장히 가볍고, 핵심기능만 포함된것이 리눅스
    - 데비안, 레드헷 계열로 크게 나뉘어져 있으며, 레드햇은 유료.
    일반적으로 데비안 계열의 우분투를 많이 사용한다.
    
    ### 운영체제의 기능
    
    - 프로세서, 기억장치, 입출력장치, 파일 및 정보 등의 자원을 관리
    - 자원을 효율적으로 관리하기 위해 자원의 스케줄링 기능 제공.
    - 사용자와 시스템간 편리한 인터페이스 제공
    - 시스템의 각종 하드웨어와 네트워크를 관리 및 제어
    - 데이터를 관리하고, 데이터 및 자원의 공유 기능 제공
    - 시스템의 오류를 검사 및 복구
    - 자원 보호 기능 제공
    - 입출력 보조 기능 제공
    
    ### 운영체제의 목적
    
    - 처리능력 향상: 일정 시간내에 시스템이 처리하는 일의 양
    - 반환시간 단축: 일정 시간내에 시스템이 처리하는 일의 양
    - 사용가능도 향상:  시스템을 사용할 필요가 있을 때 즉시 사용 가능한  정도
    - 신뢰도 향상: 시스템이 주어진 문제를 정확하게 해결하는 정도
- 프로세스와 스레드의 차이
    
    ## 프로세스
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ffe70dad-a823-4907-8a9c-6e0e1908398a/9e9d2f02-c1a3-4c97-b047-55081b3b7f9c/Untitled.png)
    
    - 운영체제로부터 자원을 할당받은 **작업의 단위**
    - 프로그램을 실행시켜, 정적인 프로그램이 동적으로 변하여, 메모리에 적재되고, CPU 자원을 할당받아 프로그램이 돌아가고 있는 상태.
    - OS에서 실행 중인 프로그램의 인스턴스
        - OS로부터 자원을 할당받은 작업의 단위
    - 각 프로세스는 독립적으로 실행되며, 다른 프로세스와 통신하기 위해 IPC 메커니즘을 사용해야 함.
        - 독립적인 실행 흐름을 가지고 있어, 다른 프로세스의 영향 X
        - 스케줄링의 대상이 되는 작업(task)와 같은 의미로 쓰인다.
    
    👉프로그램 하나 실행을 프로세스 작업 하나만으로 실행하기에는 한계가 있다.
    
    멀티 작업이 불가능하며, 다운이 완료될때까지 하루종일 기다려야한다.
    
    ## 스레드(Thread)
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ffe70dad-a823-4907-8a9c-6e0e1908398a/06595fda-17a4-46db-93af-afb75d92237a/Untitled.png)
    
    - 각 프로세스는 하나 이상의 스레드를 가질 수 있음. 프로세스의 자원을 공유한다.
    - 프로세스 내에서 실행되는 여러 실행 흐름 (프로세스의 실행 단위) 
    → 프로세스는 최소 하나의 스레드(thread)를 가지고 있음.
        - 스레드는 프로세스 내에서 상대적으로 경량이므로, 스레드 간의 전환은 프로세스 간의 전환보다 효율적
    - 그러나 스레드 간의 자원 공유에 대한 적절한 동기화가 필요하다.
    
    ### 차이점
    
    - 독립성
     →프로세스는 독립적인 메모리 공간을 가지며, 서로 영향을 미치지 않는다
     → 스레드는 메모리 공간을 공유한다.
    - 자원 사용량 → 프로세스 자원을 공유하므로, 메모리 사용이 경제적
    - 통신 방법 → 프로세스 간 통신은 IPC를 통해, 스레드 간 통신은 공유 메모리를 통해 이뤄진다.
    - 생성 및 종료 오버헤드 → 프로세스의 생성 및 종료에 오버헤드가 스레드의 비해 훨씬 크다.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ffe70dad-a823-4907-8a9c-6e0e1908398a/b295f29c-6849-4274-abdf-6ab384dd419d/Untitled.png)
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ffe70dad-a823-4907-8a9c-6e0e1908398a/dce61d7a-f7d5-42a2-9991-97dc70fc375e/Untitled.png)
    
    ⇒ 스레드는 프로세스의 Stack만 할당 받아 복사하고, 다른 부분은 프로세스내의 다른 스레드들과 공유된다.
    
    📌각각의 스레드는 별도의 stack을 가지고, heap 메모리를 공유하기 때문에, 서로 다른 스레드에서 가져와 읽고 쓸 수 있게 된다.
    
    즉, 자원을 공유하면서 독립적인 실행 흐름을 가질 수 있게 된다.
    
    📌반면 프로세스는 기본적으로 다른 프로세스의 메모리에 직접 접근할 수는 없다.
    
- PCB란(Process Control Block)
    - 운영체제에서 프로세스를 관리하기 위해 해당 프로세스의 **상태 정보**를 담고 있는 자료구조
    - Context Switching시, 기존 프로세스의 **임시 저장소** 역할.
    - 프로세스가 생성되면, 메모리에 해당 프로세스의 PCB가 함께 생성, 프로세스 종료시에 삭제
    
    📌운영체제는 PCB에 담긴 프로세스 고유정보를 통해 프로세스를 관리하며, 프로세스의 실행상태를 파악하고, 우선순위를 조정하며, 스케줄링을 수행하고, 다른 프로세스와의 동기화를 제어한다.
    
- Context Switching이 무엇이며 왜 필요한가
    - CPU가 한 프로세스에서 다른 프로세스로 전환할때 발생하는 일련의 과정. CPU의 동시성 특성의 핵심이다.
    - 동작 중인 프로세스가 대기를 하면서, 해당 프로세스의 상태(Context)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스 상태 복구하는 작업.
    
    📌 Context Switching 동작시에 다음번 프로세스는 스케줄러가 결정하게 된다.
    
    **Context Switching Overhead**
    
    - 이러한 컨텍스트 스위칭 과정은 변경과정에서 시스템에 많은 부담을 주게된다.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ffe70dad-a823-4907-8a9c-6e0e1908398a/a354438b-2aef-4c0a-afb4-686046cee29c/Untitled.png)
    
    Process B가 바로 실행되지 않고,  조금 이따가 실행되는것을 볼 수 있다.
    
    이 간극이 바로 컨텍스트 스위칭 오버헤드이다.
    
    📌이 오버헤드가 심하면 오히려 멀티 태스크 환경이 싱글 태스크보다도 성능저하가 일어날 수 도 있다.
    
- 멀티스레딩이란
    
    ### 멀티태스킹 원리
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ffe70dad-a823-4907-8a9c-6e0e1908398a/8edb3960-d83b-4292-9ac1-008fbad5d6ec/Untitled.png)
    
    - CPU 한개는 여러개의 코어를 가질 수 있다.
    - 4개의 코어는 명령어를 메모리에서 뽑아서 사용하는 반도체 유닛, 즉 물리적인 코어갯수가 4개 라는 뜻이다.
    - 8쓰레드는 논리적 코어 갯수를 말한다.
    물리적 코어 하나가, 스레드 두개 이상을 동시에 실행 가능하다는 의미다
    
    ⇒ 컴퓨터에서 사용하는 수십, 수백개 프로세스를 고작 8개의 논리적인 스레드로 처리하나?
    
    👉CPU의 특성인 병렬성과 동시성으로 처리한다.
    
    ### 병렬성
    
    위의 내용처럼 다수의 코어를 병렬적으로 스레드를 돌려 작업을 동시 수행하는것.
    
    ### 동시성
    
    1개의 코어 내에서 여러 프로세스를 잘게 나누어 번갈아가면서 조금씩 처리한다.
    
    사용자는 마치 동시에 실행되는 것처럼 보인다.
    
    이렇게 번갈아 바꾸는 것을 Context Switching이라고 부른다.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ffe70dad-a823-4907-8a9c-6e0e1908398a/e18104a6-ffd8-4f51-9fc8-a10a11a6fb67/Untitled.png)
    
    ## 멀티 프로세스
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ffe70dad-a823-4907-8a9c-6e0e1908398a/d77c56fd-2869-40ef-a050-e07eae641570/Untitled.png)
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ffe70dad-a823-4907-8a9c-6e0e1908398a/db8fff34-9e3b-4c48-88bf-d541586d61c8/Untitled.png)
    
    - 멀티 프로세스 내부를 보면, 하나의 부모 프로세스가 여러개의 자식 프로세스를 생성하여, 다중 프로세스를 구성하는 구조
    - 부모 프로세스는 자식 프로세스의 PID를 알고 있으며, 이를 통해 자식 프로세스를 제어할 수 있다.
    - 서로 통신은 가능하지만, 부모와 자식은 서로 다른 프로세스로 독립적으로 실행 된다. Ex) 웹 브라우저 상단 탭
    
    ### 멀티 프로세스의 장점과 단점
    
    ### 장**점**
    
    1. **프로그램의 안정성**
    
    ⇒ 각 프로세스가 독립적인 메모리 공간을 가지므로, 한 프로세스가 비정상적으로 종료되어도, 다른 프로세스에 영향을 주지 않는다. 따라서 프로그램 전체의 안정성을 확보할 수 있다.
    
    1. **프로그램의 병렬성**
    
    ⇒ 멀티 프로세스 만의 장점은 아니지만, 여러 프로세스를 병렬적으로 실행시켜 성능을 향상시킬 수 있다.
    
    1. **시스템 확장성**
    
    ⇒ 각 프로세스가 독립적이므로, 새로운 기능, 모듈 추가 및 수정시 다른 프로세스에 영향을 주지 않는다.
    
    Ex)하나의 컴퓨터의 여러개의 서버 프로세스를 증설하여 사용하는 경우
    
    이런식으로 여러대의 서버에 요청을 로드밸런싱하여 분산시킬 수 있다.
    
    ### 단점
    
    1. **Context Switching Overhead**
    
    ⇒ 스레드를 스위칭하는 것보다 프로세스를 스위칭 하는것은 더 많은 비용과 오버헤드가 든다.
    
    👉 이를 최소화하기 위해, 프로세스 수를 적정하게 유지하거나, I/O 바운드 작업이 많은 프로세스, CPU 작업이 많은 프로세스를 분리하여 관리하고, CPU 캐시를 효율적으로 활용하는 방법이 있다.
    
    1. 자원 공유 비효율성
    
    ⇒ 멀티 프로세스는 각각 독립적인 메모리 공간을 가지므로, 결과적으로는 메모리 사용량이 증가하게 된다. 
    
    또한 프로세스간 자원 공유시에는 어렵고 복잡한 통신 기법인 IPC를 사용하여야 한다.
    
    심지어 IPC 자체로 오버헤드가 일어나 성능저하가 발생할 수 있다.
    
    ## 멀티 스레드
    
    ⇒ 하나의 프로세스 안에 여러개의 스레드를 일컫는다.
    
    멀티 프로세스가 웹 브라우저의 여러 탭이라면, 멀티 스레드는 단일 탭내의 이벤트 루프, 네트워크 처리, I/O 및 기타작업 동시 처리로 비교할 수 있다.
    
    ### 멀티 스레드의 장점과 단점
    
    ### 장점
    
    1. **프로세스보다 가벼움**
    
    ⇒ 스레드는 스택을 제외한 대부분의 자원을 서로 공유하기 때문에, 기본적으로 내장된 데이터 용량이 작다. 따라서 스레드 생성, 제거가 쉽다.
    
    1. **자원의 효율성**
    
    ⇒ 여러 스레드간 Heap 영역과 같은 공유 메모리에 대해 스레드간에 자원 공유가 가능하다.
    
    IPC통신을 사용하지 않고, 데이터를 공유하기에 자원소모가 적다.
    
    1.  **응답시간 단축**
    
    ⇒ 가벼운 스레드는 컨텍스트 스위칭 오버헤드도 적고, 자원공유도 쉽다.
    
    따라서 응답시간이 매우 빠르다.
    
    ### 단점
    
    1. **안정성 문제**
    
    ⇒ 멀티 스레드는 하나의 자원을 공유하므로, 하나의 스레드에 문제가 발생하면, 다른 스레드도 영향을 받는다.
    
    1. **동기화로 인한 성능저하**
    
    ⇒ 여러개의 스레드가 공유자원에 동시 접근할 수 있기때문에, 문제가 될 수 있다.
    
    의도치 않은 자원을 사용할 수 있다.
    
    📌동기화 작업을 통해 해결할 수 있지만, 동기화작업 자체로 병목현상을 일으킬 수 있다.
    
    1. **데드락 (교착상태)**
    
    ⇒ 공유자원에 대한 동시 접근으로 인한 문제로, 다수의 쓰레드가 서로 절대 불가능한 일을 무한정 기다리게 되는 문제이다.
    
- Race Condition, Critical Section
    
    ### Race Condition
    
    공유자원에 여러개의 스레드나 프로세스가 동시에 접근할시, 자원의 일관성이 깨지며, 의도치 않은 결과를 가져오는 것을 말한다.
    
    ### Critical Section
    
    임계구역을 뜻하며, Race Condition을 일으킬 수 있는 코드영역을 뜻한다.
    
    📌이러한 문제들을 다양한 동기화 방법을 통해서 해결할 수 있다.
    
- 프로세스, 스레드 동기화 방법
    
    ⇒ 시스템의 공유자원을 여러 쓰레드가 동시에 접근하는 경우, 데이터 일관성이 깨질 수 있다.
    
    따라서 이렇게 자원에 접근 가능한 쓰레드를 통제해서, 멀티 쓰레드의 문제를 해결하는 방법을 동기화라고 한다.
    
    ### **1. 실행 순서 제어를 위한 동기화**
    
    프로세스들을 올바른 순서대로 실행하기 위한 동기화
    
    ### **2. 상호 배제를 위한 동기화**
    
    동시에 접근해서는 안되는 자원에 하나의 프로세스만 접근하게 하는 동기화
    
    📗임계구역
    
    - 동시에 실행하면 문제가 발생하는 자원에 접근하는 **코드 영역**
    - 임계 구역에 동시접근하면, 자원의 일관성이 깨질 수 있으며, 이를 **race condition이라고 한다.**
    
    **상호배제를 위한 동기화 세가지 원칙**
    
    ⇒ 운영체제가 임계 구역 문제를 해결하는 세가지 원칙
    
    1. 상호배제
    - 한 프로세스가 임계 구역에 진입했다면, 다른 프로세스는 들어올 수 없다.
    1. 진행
    - 임계 구역에 어떤 프로세스도 진입하지 않았다면, 진입하고자 하는 프로세스는 들어갈 수 있어야 한다.
    1. 유한대기
    - 한 프로세스가 임계구역에 진입하고 싶다면 언젠가는 임계구역에 들어올 수 있어야 한다.
    
    대표적인 동기화 기법 3가지
    
    - 뮤텍스 락
    ⇒ 상호배제를 위한 동기화 도구, 임계 구역을 잠그는 역할
    - 세마포
    - 모니터
- CPU 스케줄링 알고리즘에는 어떤 것이 있는가
    
    ### CPU 스케줄링의 목표
    
     1.  CPU 이용률은 높게,
    
    1. 주어진 시간에 많은 일을 하도록, 
    2. 준비큐에 있는 프로세스는 적게, 
    3. 응답시간은 짧게.
    
    ## 비선점형 스케줄링
    
    - 어떤 프로세스가 CPU를 점유하고 있다면 이를 뺏을 수 없는 방식. 강제로 프로세스 중지x
    - Context Switching 부하가 상대적으로 적지만, 프로세스 배치에 따라 효율성 차이가 많이 나게 된다.
    1. **FCFS (First Come, First Served)**
    
    ⇒ 가장먼저 요청한 프로세스에 CPU를 할당. 오래걸리는 프로세스로 인해 전체 OS가 느려지는 현상이 일어날 수 있다.
    
    1. **SJF (Shortest Job First)**
    
    ⇒ 실행시간이 가장 짧은 프로세스를 먼저 실행. but 프로세스의 CPU 실행시간을 예측하는것이 어렵다.
    
    긴시간을 필요로 하는 프로세스는 우선순위가 계속밀려서 무기한 대기하는 기아현상 발생
    
    1. **우선순위 (Priority)**
    
    ⇒ 각각의 프로세스에 우선순위 넘버가 있는 알고리즘.
    SJF의 기아현상을 우선순위를 높여서 해결할 수 있다.
    
    ## 선점형 스케줄링
    
    - 현대 운영체제가 사용하는 방식으로, 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 이를 강제로 뺏을 수 있는 방식. 알고리즘에 따라 강제로 중단시키고 다른 프로세스에 CPU를 할당하는 방식이다.
    - 처리 시간이 매우 긴 프로세스의 CPU 사용 독점을 막을 수 있어 효율적인 운영이 가능하지만 잦은 컨텍스트 스위칭으로 인해 오버헤드(Overhead)가 커질 수 있다
    1. **라운드 로빈 (RR, Round Robin)**
    
    ⇒ 각 프로세스에 동일한 할당시간 부여, 해당시간 동안만 CPU 이용. 할당시간 내 처리완료 못하면, 강제 중단후 다음작업으로 넘어감.
    
    응답시간은 빠르지만, 할당시간이 길면, 그냥 FCFS와 다를바없고, 너무 짧으면 계속 컨텍스트 스위칭되어 CPU의 1/n속도로 작동하는 것처럼 된다.
    
    1. **SRTF (Shortest Remaining Time First)**
    
    ⇒ 현재 실행되고 있는 프로세스의 남은 시간보다, 더 빨리 끝날 수 있는 짧은 프로세스가 들어오면, 현재 실행되는 프로세스 중단하고, 짧은 프로세스 실행.
    
    평균 대기 시간 줄일 수 있지만, 다음 프로세스의 시간을 예측하는것이 어렵다.
    
    1. **다단계 큐 (Multilevel Queue)**
    
    ⇒ 우선순위에 따른 준비 큐가 여러 큐들로 나뉘고, 각각의 큐는 각자의 스케줄링 알고리즘을 가지고 있다.
    
    우선순위가 높은 큐부터 처리되기 때문에, 낮은 큐의 프로세스가 처리가 안되는 기아현상 발생될 수 있다.
    
    각 큐 사이 프로세스들이 이동할 수 없어, 유연성이 떨어진다.
    
- DeadLock이란
    
    ⇒ DeadLock 이란, 다수의 프로세스나 스레드가 서로 자원을 점유하고, 다른 프로세스나 스레드가 점유한 자원을 기다리는 상황에서 발생하는 교착상태를 말한다.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ffe70dad-a823-4907-8a9c-6e0e1908398a/726b2232-89ca-4f5c-8382-e3760cde0dd2/Untitled.png)
    
    👉서로의 자원을 대기하여 절대 불가능한 일을 계속적으로 기다리는 상황
    

## 심화

- 스케줄링 Queue 종류
    
    📌준비 상태의 프로세스 중 우선순위가 높은 프로세스에게 CPU를 할당하는 과정을 스케줄링이라 한다.
    
    이러한 스케줄링을 위해 사용하는 데이터베이스는 큐로 구성되며, PCB들이 리스트 형태로 연결되어 있다.
    
    ### Job queue(작업 큐)
    
    - 시스템에 제출된 모든 작업들이 대기하는 큐
    - 작업 큐에 있는 프로세스는 그냥 시스템에 추가만 된 상태로, 실행대기 상태가 아님.
    - 장기 스케줄러에 의해 선택된 작업들이 준비 큐로 이동하여 실행 대기상태가 됨
    
    ### ready queue(준비 큐)
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ffe70dad-a823-4907-8a9c-6e0e1908398a/224d65c1-4d91-4930-a27c-20f2765b2773/Untitled.png)
    
    - CPU 점유하고 있는 실행 상태에 도달하기 직전 상태에 있는 프로세스가 대기하고 있는 공간.
    - 머리와 꼬리부분은 PCB의 첫번째 항목과 마지막 항목의 포인터를 가리킨다
    - CPU를 할당받기 위해 실행을 기다리는 상태
    
    ### wait queue(대기 큐)
    
    - 입출력(I/O)작업이나 다른 이벤트를 기다리는 프로세스들을 저장하는 큐
    - 입출력이 완료되거나 특정이벤트가 발생하면, 해당 프로세스는 준비 큐로 이동하여 CPU를 할당 받을 수 있음.
- 스케줄러의 종류
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ffe70dad-a823-4907-8a9c-6e0e1908398a/74a71f80-e055-4137-b682-a974ff2967bd/Untitled.png)
    
    1. 장기 스케줄러
    - 작업 큐에 있는 프로세스들 중 어떤 것이 메모리에 적재될지를 결정
    - 메모리에 적재된 프로세스들은 준비 큐로 이동하게 되고, CPU를 할당받을 수 있게됨
    1. 단기 스케줄러
    - 준비 큐에 있는 프로세스들 중 어떤 것이 실제로 CPU를 할당받아 실행될지를 결정
    - 준비 큐에서 선택된 프로세스가 CPU를 할당받아 실행
    1. 중기 스케줄러
    - 메모리에서 쫓겨난 프로세스를 디스크로 스왑 or 디스크에서 메모리로 적재
    - 메모리 부족시 일부 프로세스를 디스크로 스왑하고, 필요한 경우 디스크에서 메모리로 프로세스를 적재
- 동기화 문제에서 Busy Waiting이란 무엇이며 어떻게 해결할 수 있나
    
    Busy Waiting - 바쁜대기
    
    - OS에서 원하는 자원을 얻기위해 기다리는 것이 아니라 권한을 얻을 때까지 확인하는 것을 의미,
    - CPU의 자원을 계속 낭비하는 쓰레드 동기화 방식.
    
    📌이를 막기위해, 뮤텍스 세마포어, 모니터 방법을 사용한다.
    
    ⇒ CPU가 무한루프를 통해 확인하는것이 아닌, 다른 쓰레드가 공유자원을 모두 사용하면, 기다리던 쓰레드를 깨우는 방식.
    
- DeadLock을 어떻게 해결할 수 있나
    1. **예방 (Prevention):**
        - 교착 상태의 발생을 미리 방지하는 것이 가장 효과적입니다.
        - 상호 배제, 점유 대기, 비선점, 순환 대기 등의 4가지 교착 상태 조건 중 하나 이상을 제거함으로써 교착 상태를 예방합니다.
    2. **회피 (Avoidance):**
        - 시스템이 자원을 할당하는 동안 교착 상태의 가능성을 피하는 방법입니다.
        - 은행원 알고리즘이나 자원 할당 그래프 알고리즘과 같이 안전한 상태를 유지하면서 자원을 할당합니다.
        - 단, 회피 방법은 효율적이지만 항상 가능하지 않을 수 있습니다.
    3. **검출 및 회복 (Detection and Recovery):**
        - 교착 상태가 발생하면 이를 검출하고 회복하는 방식입니다.
        - 주기적인 검사나 자원 할당 그래프를 통한 검출이 가능합니다.
        - 검출된 교착 상태를 해결하기 위해 해당 프로세스 중 하나를 강제로 종료하거나 자원을 해제하는 방법을 사용할 수 있습니다
- 크롬 브라우저에서 각각의 크롬 탭은 프로세스일까, 쓰레드일까?
    
    **프로세스이다.**
    
    크롬은 멀티 프로세스를 사용하며,  IPC를 사용한다. 특정 탭이 응답하지 않을때는 동작하지 않는 탭의 프로세스를 재시작 시켜버린다. 
    
    또한 이는 다른 탭에 영향을 주지 않는다.
    
    성능면에서 유리한 멀티 스레드로 탭을 생성할 경우, 악성 개발자가 모든 공유자원의 주도권을 가진 상태로 죽었을때, 전체에 영향을 미칠 수 있다.
    
    따라서 보안성과 안전성을 고려하여 프로세스를 채택하였다.
    
- 프로세스의 종류에는 무엇이 있나
    1. **시스템 프로세스 (System Processes):**
        - 운영 체제가 실행하는 프로세스로, 시스템의 핵심 기능과 관련된 작업을 처리합니다.
        - 예: init 프로세스, 스케줄러, 디바이스 드라이버 등.
    2. **사용자 프로세스 (User Processes):**
        - 사용자가 실행시키는 일반적인 응용 프로그램이나 작업을 수행하는 프로세스입니다.
        - 예: 워드 프로세서, 웹 브라우저, 게임 등.
    3. **백그라운드 프로세스 (Background Processes 또는 Daemon Processes):**
        - 사용자와 상호 작용하지 않고 시스템 서비스를 제공하는 프로세스로, 주로 시스템이 부팅될 때 시작됩니다.
        - 예: 로그인 서비스, 네트워크 서비스, 백업 서비스 등.
    4. **서버 프로세스 (Server Processes):**
        - 네트워크를 통해 요청을 처리하고 응답하는 서비스를 제공하는 프로세스입니다.
        - 예: 웹 서버, 데이터베이스 서버 등.